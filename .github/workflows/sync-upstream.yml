name: Sync Upstream

on:
  schedule:
    # Run daily at 4 AM UTC (5 AM Budapest time)
    - cron: '0 4 * * *'
  workflow_dispatch:
    inputs:
      force_sync:
        description: 'Force sync even if no new commits'
        required: false
        default: false
        type: boolean

env:
  UPSTREAM_REPO: 'morpheus65535/bazarr'
  UPSTREAM_BRANCH: 'master'
  FORK_BRANCH: 'main'
  # Files that should always keep our fork's version during merge conflicts
  # These are fork-specific customizations that should never be overwritten
  FORK_PROTECTED_FILES: |
    README.md
    package_info
    bazarr/app/check_update.py
    custom_libs/subliminal_patch/providers/opensubtitles_scraper.py
    .github/workflows/sync-upstream.yml
    .github/workflows/build-docker.yml
    Dockerfile
    docker-compose.yml
    docker/entrypoint.sh
    .dockerignore
    .gitattributes
    .gitmodules
    docs/FORK_MAINTENANCE.md

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    outputs:
      has_changes: ${{ steps.check_changes.outputs.has_changes }}
      upstream_version: ${{ steps.get_version.outputs.version }}
      sync_status: ${{ steps.sync.outputs.status }}

    steps:
      - name: Checkout Fork
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          submodules: recursive

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add Upstream Remote
        run: |
          git remote add upstream https://github.com/${{ env.UPSTREAM_REPO }}.git || true
          git fetch upstream ${{ env.UPSTREAM_BRANCH }}

      - name: Check for New Commits
        id: check_changes
        run: |
          UPSTREAM_COMMITS=$(git rev-list HEAD..upstream/${{ env.UPSTREAM_BRANCH }} --count)
          echo "Upstream has $UPSTREAM_COMMITS new commit(s)"
          
          if [ "$UPSTREAM_COMMITS" -gt 0 ] || [ "${{ inputs.force_sync }}" == "true" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "commit_count=$UPSTREAM_COMMITS" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No new changes from upstream"
          fi

      - name: Get Upstream Version
        id: get_version
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          # Get the latest tag from upstream
          git fetch upstream --tags
          LATEST_TAG=$(git describe --tags --abbrev=0 upstream/${{ env.UPSTREAM_BRANCH }} 2>/dev/null || echo "v0.0.0")
          echo "Latest upstream tag: $LATEST_TAG"
          echo "version=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Attempt Merge
        id: sync
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          echo "Attempting to merge upstream/${{ env.UPSTREAM_BRANCH }} into ${{ env.FORK_BRANCH }}..."
          
          # Configure merge to favor our version for protected files
          echo "Setting up merge attributes for protected files..."
          
          # Create .gitattributes for merge strategy if it doesn't exist
          cat >> .gitattributes << 'EOF'
          # Fork-specific files - always keep ours during merge
          README.md merge=ours
          package_info merge=ours
          bazarr/app/check_update.py merge=ours
          .github/workflows/sync-upstream.yml merge=ours
          .github/workflows/build-docker.yml merge=ours
          Dockerfile merge=ours
          docker-compose.yml merge=ours
          docker/entrypoint.sh merge=ours
          .dockerignore merge=ours
          .gitattributes merge=ours
          .gitmodules merge=ours
          docs/FORK_MAINTENANCE.md merge=ours
          EOF
          
          # Configure the 'ours' merge driver
          git config merge.ours.driver true
          
          # Try to merge
          if git merge upstream/${{ env.UPSTREAM_BRANCH }} --no-edit -m "Merge upstream ${{ env.UPSTREAM_REPO }}/${{ env.UPSTREAM_BRANCH }}"; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "Merge successful!"
            
            # Restore our fork-specific files in case they were modified
            echo "Ensuring fork-specific files are preserved..."
            git checkout HEAD -- README.md 2>/dev/null || true
            git checkout HEAD -- package_info 2>/dev/null || true
            git checkout HEAD -- bazarr/app/check_update.py 2>/dev/null || true
            git checkout HEAD -- .gitattributes 2>/dev/null || true
            git checkout HEAD -- .gitmodules 2>/dev/null || true
            
            # Check if we need to commit the restored files
            if ! git diff --quiet; then
              git add -A
              git commit --amend --no-edit
            fi
          else
            echo "status=conflict" >> $GITHUB_OUTPUT
            echo "Merge conflict detected!"
            
            # Try to auto-resolve conflicts in protected files by keeping ours
            echo "Attempting to auto-resolve conflicts in fork-specific files..."
            CONFLICT_FILES=$(git diff --name-only --diff-filter=U)
            RESOLVABLE=true
            
            for file in $CONFLICT_FILES; do
              case "$file" in
                README.md|package_info|bazarr/app/check_update.py|.github/workflows/sync-upstream.yml|.github/workflows/build-docker.yml|Dockerfile|docker-compose.yml|docker/entrypoint.sh|.dockerignore|.gitattributes|.gitmodules|docs/FORK_MAINTENANCE.md)
                  echo "Auto-resolving conflict in fork-specific file: $file (keeping ours)"
                  git checkout --ours "$file"
                  git add "$file"
                  ;;
                custom_libs/subliminal_patch/providers/opensubtitles_scraper.py)
                  # This file is fork-only, keep ours
                  echo "Auto-resolving conflict in fork-only file: $file (keeping ours)"
                  git checkout --ours "$file"
                  git add "$file"
                  ;;
                *)
                  echo "Cannot auto-resolve conflict in: $file (needs manual review)"
                  RESOLVABLE=false
                  ;;
              esac
            done
            
            # Check if all conflicts were resolved
            REMAINING_CONFLICTS=$(git diff --name-only --diff-filter=U)
            if [ -z "$REMAINING_CONFLICTS" ]; then
              echo "All conflicts auto-resolved!"
              git commit -m "Merge upstream ${{ env.UPSTREAM_REPO }}/${{ env.UPSTREAM_BRANCH }} (auto-resolved fork-specific conflicts)"
              echo "status=success" >> $GITHUB_OUTPUT
            else
              echo "Some conflicts require manual resolution: $REMAINING_CONFLICTS"
              git merge --abort
            fi
          fi

      - name: Push Changes
        if: steps.sync.outputs.status == 'success'
        run: |
          git push origin ${{ env.FORK_BRANCH }}
          echo "Successfully synced with upstream!"

      - name: Create Conflict Branch
        id: conflict_branch
        if: steps.sync.outputs.status == 'conflict'
        run: |
          BRANCH_NAME="sync/upstream-$(date +%Y%m%d-%H%M%S)"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          git checkout -b $BRANCH_NAME
          
          # Attempt merge again to create conflict markers
          git merge upstream/${{ env.UPSTREAM_BRANCH }} --no-edit || true
          
          # Stage all files (including conflicts)
          git add -A
          git commit -m "WIP: Merge conflicts from upstream sync" || true
          git push origin $BRANCH_NAME

      - name: Create Conflict PR
        if: steps.sync.outputs.status == 'conflict'
        uses: actions/github-script@v7
        with:
          script: |
            const branchName = '${{ steps.conflict_branch.outputs.branch_name }}';
            const upstreamVersion = '${{ steps.get_version.outputs.version }}';
            
            const pr = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ”„ Sync Conflict: Upstream ${upstreamVersion}`,
              head: branchName,
              base: '${{ env.FORK_BRANCH }}',
              body: `## âš ï¸ Merge Conflict Detected
              
            This PR was automatically created because there were conflicts when syncing with upstream.
            
            **Upstream Repository:** [${{ env.UPSTREAM_REPO }}](https://github.com/${{ env.UPSTREAM_REPO }})
            **Upstream Branch:** \`${{ env.UPSTREAM_BRANCH }}\`
            **Upstream Version:** \`${upstreamVersion}\`
            
            ### Required Actions
            
            1. Check out this branch locally
            2. Resolve the merge conflicts
            3. Test your changes
            4. Merge this PR
            
            \`\`\`bash
            git fetch origin ${branchName}
            git checkout ${branchName}
            # Resolve conflicts in your editor
            git add .
            git commit -m "Resolve merge conflicts from upstream sync"
            git push origin ${branchName}
            \`\`\`
            
            ### Files Modified in Your Fork (likely conflict sources)
            - \`custom_libs/subliminal_patch/providers/opensubtitles_scraper.py\`
            - \`custom_libs/subliminal_patch/providers/opensubtitles.py\`
            - Frontend provider configuration files
            
            ---
            ðŸ¤– *This PR was automatically created by the upstream sync workflow*
            `
            });
            
            // Add labels
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.data.number,
              labels: ['sync-conflict', 'needs-review']
            });
            
            console.log(`Created PR #${pr.data.number}`);

      - name: Summary
        run: |
          echo "## Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check_changes.outputs.has_changes }}" == "false" ]; then
            echo "âœ… No new changes from upstream" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.sync.outputs.status }}" == "success" ]; then
            echo "âœ… Successfully synced with upstream" >> $GITHUB_STEP_SUMMARY
            echo "- **Upstream Version:** ${{ steps.get_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Merge conflicts detected - PR created for manual resolution" >> $GITHUB_STEP_SUMMARY
            echo "- **Branch:** ${{ steps.conflict_branch.outputs.branch_name }}" >> $GITHUB_STEP_SUMMARY
          fi

  # Trigger Docker build if sync was successful
  trigger-build:
    needs: sync
    if: needs.sync.outputs.has_changes == 'true' && needs.sync.outputs.sync_status == 'success'
    uses: ./.github/workflows/build-docker.yml
    with:
      version_tag: ${{ needs.sync.outputs.upstream_version }}
    secrets: inherit